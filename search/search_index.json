{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation","text":""},{"location":"#personalised-mutual-hazard-networks","title":"Personalised Mutual Hazard Networks","text":"<p>Principled probabilistic modelling with Mutual Hazard Networks.</p> <ul> <li>Documentation: https://cbg-ethz.github.io/pMHN</li> <li>Source code: https://github.com/cbg-ethz/pMHN</li> <li>Bug reports: https://github.com/cbg-ethz/pMHN/issues</li> </ul>"},{"location":"#running-the-workflows","title":"Running the workflows","text":"<p>To facilitate reproducibility we use Snakemake. We recommend creating a new virtual environment (e.g., using Micromamba) and installing Snakemake as described in their documentation.</p> <p>Once the environment is set, the package can be installed using</p> <pre><code>$ pip install -e .  # Note -e which will allow modifying the code when needed\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>We use Poetry to control dependencies.</p> <p>When Poetry is installed, clone the repository and type</p> <pre><code>$ poetry install --with dev\n</code></pre> <p>to install the package with the dependencies used for development.</p> <p>At this stage you should be able to use Pytest to run unit tests:</p> <pre><code>$ poetry run pytest\n</code></pre> <p>Alternatively, you may want to work inside Poetry environment:</p> <pre><code>$ poetry shell\n$ pytest\n</code></pre> <p>When you submit a pull request, automated continuous integration tests will be run. They include unit tests as well as code quality checks. To run the code quality checks automatically at each commit made, we use pre-commit. To activate it run:</p> <pre><code>$ poetry shell  # If it is not already active\n$ pre-commit install\n</code></pre>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This package is built around LearnMHN (the backend for Mutual Hazard Networks) and PyMC (probabilistic programming framework).</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#simulations","title":"Simulations","text":""},{"location":"api/#pmhn.simulate_dataset","title":"<code>pmhn.simulate_dataset(rng, n_points, theta, mean_sampling_time)</code>","text":"<p>Simulates a dataset of genotypes and sampling times.</p> <p>Parameters:</p> Name Type Description Default <code>rng</code> <p>the random number generator.</p> required <code>n_points</code> <code>int</code> <p>number of points to simulate.</p> required <code>theta</code> <code>ndarray</code> <p>the log-MHN matrix. Can be of shape (n_mutations, n_mutations) or (n_points, n_mutations, n_mutations).</p> required <code>mean_sampling_time</code> <code>Union[ndarray, float, Sequence[float]]</code> <p>the mean sampling time. Can be a float (shared between all data point) or an array of shape (n_points,).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>sampling times, shape (n_points,)</p> <code>ndarray</code> <p>genotypes, shape (n_points, n_mutations)</p>"},{"location":"api/#pmhn.simulate_genotype_known_time","title":"<code>pmhn.simulate_genotype_known_time(rng, theta, sampling_time=1.0, start_state=None)</code>","text":""},{"location":"api/#pmhn.simulate_trajectory","title":"<code>pmhn.simulate_trajectory(rng, theta, max_time, start_state=None)</code>","text":"<p>Simulates a trajectory of the jump Markov chain.</p> <p>Parameters:</p> Name Type Description Default <code>rng</code> <p>the random number generator.</p> required <code>theta</code> <code>ndarray</code> <p>the log-MHN matrix, theta[i, j] describes the additive log-hazard of mutation <code>j</code> onto appearance of mutation <code>i</code></p> required <code>max_time</code> <code>float</code> <p>the maximum time to simulate.</p> required <code>start_state</code> <code>Optional[State]</code> <p>the initial state of the chain. By default, it's the state with all 0s.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[tuple[float, State]]</code> <p>A list of (time, state) pairs, where <code>time</code> is the time of the jump and <code>state</code></p> <code>list[tuple[float, State]]</code> <p>is the state to which the jump appeared</p> <code>list[tuple[float, State]]</code> <p>We initialize the list with (0, start_state), i.e., the initial state at time 0.</p>"},{"location":"api/#pmhn.sample_spike_and_slab","title":"<code>pmhn.sample_spike_and_slab(rng, n_mutations, diag_mean=0.0, diag_sigma=1.0, offdiag_effect=1.0, p_offdiag=0.2)</code>","text":"<p>Samples a matrix using diagonal terms from a normal distribution and offdiagonal terms sampled from spike and slab distribution.</p> <p>Parameters:</p> Name Type Description Default <code>rng</code> <p>NumPy random number generator.</p> required <code>n_mutations</code> <code>int</code> <p>number of mutations.</p> required <code>diag_mean</code> <code>float</code> <p>mean of the normal distribution used to sample diagonal terms.</p> <code>0.0</code> <code>diag_scale</code> <p>standard deviation of the normal distribution used to sample diagonal terms.</p> required <code>offdiag_effect</code> <code>float</code> <p>the standard deviation of the slab used to sample non-zero offdiagonal terms</p> <code>1.0</code> <code>p_offdiag</code> <code>float</code> <p>the probability of sampling a non-zero offdiagonal term.</p> <code>0.2</code>"},{"location":"api/#likelihood-backends","title":"Likelihood backends","text":""},{"location":"api/#pmhn.MHNBackend","title":"<code>pmhn.MHNBackend</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>A backend for learning the MHN model.</p> <p>All implementations of this interface must be able to compute the gradient and the loglikelihood of a given set of mutations and theta (log-MHN) matrix.</p>"},{"location":"api/#pmhn.MHNBackend.gradient_and_loglikelihood","title":"<code>gradient_and_loglikelihood(mutations, theta)</code>","text":"<p>Compute the gradient and the loglikelihood of a given set of mutations</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>ndarray</code> <p>log-MHN matrix, shape (n_genes, n_genes)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>gradient of the loglikelihood with respect to theta, shape (n_genes, n_genes)</p> <code>float</code> <p>loglikelihood of the given mutations, float</p>"},{"location":"api/#pmhn.MHNLoglikelihood","title":"<code>pmhn.MHNLoglikelihood</code>","text":"<p>             Bases: <code>Op</code></p> <p>A wrapper around the MHN loglikelihood, so that it can be used in PyMC models.</p> <p>This operation expects the (unconstrained/log) MHN matrix of shape (n_genes, n_genes).</p>"},{"location":"api/#pmhn.MHNLoglikelihood.perform","title":"<code>perform(node, inputs, outputs)</code>","text":"<p>This is the method which is called by the operation.</p> <p>It calculates the loglikelihood.</p> Note <p>The arguments and the output are PyTensor variables.</p>"},{"location":"api/#pmhn.MHNCythonBackend","title":"<code>pmhn.MHNCythonBackend</code>","text":"<p>             Bases: <code>MHNBackend</code></p> <p>A simple wrapper around the Cython implementation of the gradient and loglikelihood.</p>"},{"location":"api/#pmhn.MHNJoblibBackend","title":"<code>pmhn.MHNJoblibBackend</code>","text":"<p>             Bases: <code>MHNBackend</code></p> <p>Calculates the gradient and the loglikelihood by using multiple processes via Joblib, sending them individual patient data.</p>"},{"location":"api/#pmhn.PersonalisedMHNLoglikelihood","title":"<code>pmhn.PersonalisedMHNLoglikelihood</code>","text":"<p>             Bases: <code>Op</code></p> <p>A wrapper around the MHN loglikelihood, so that it can be used in PyMC models.</p> <p>This operation expects the (unconstrained/log) MHN matrix of shape (n_genes, n_genes).</p>"},{"location":"api/#pmhn.PersonalisedMHNLoglikelihood.perform","title":"<code>perform(node, inputs, outputs)</code>","text":"<p>This is the method which is called by the operation.</p> <p>It calculates the loglikelihood.</p> Note <p>The arguments and the output are PyTensor variables.</p>"},{"location":"api/#priors","title":"Priors","text":""},{"location":"api/#pmhn.prior_horseshoe","title":"<code>pmhn.prior_horseshoe(n_mutations, baselines_mean=0, baselines_sigma=10.0, tau=None)</code>","text":"<p>Constructs PyMC model with horseshoe prior on the off-diagonal terms.</p> <p>For full description of this prior, see C.M. Caralho et al., Handling Sparsity via the Horseshoe, AISTATS 2009.</p> <p>Parameters:</p> Name Type Description Default <code>n_mutations</code> <code>int</code> <p>number of mutations</p> required <code>baselines_mean</code> <code>float</code> <p>prior mean of the baseline rates</p> <code>0</code> <code>baselines_sigma</code> <code>float</code> <p>prior standard deviation of the baseline rates</p> <code>10.0</code> <p>Returns:</p> Type Description <code>Model</code> <p>PyMC model. Use <code>model.theta</code> to access the (log-)mutual hazard network variable, which has shape (n_mutations, n_mutations)</p>"},{"location":"api/#pmhn.prior_regularized_horseshoe","title":"<code>pmhn.prior_regularized_horseshoe(n_mutations, baselines_mean=0, baselines_sigma=10.0, sparsity_sigma=0.3, c2=None, tau=None, lambdas_dof=5)</code>","text":"<p>Constructs PyMC model for regularized horseshoe prior. To access the (log-)mutual hazard network parameters, use the <code>theta</code> variable.</p> <p>Parameters:</p> Name Type Description Default <code>n_mutations</code> <code>int</code> <p>number of mutations</p> required <code>baselines_mean</code> <code>float</code> <p>prior mean of the baseline rates</p> <code>0</code> <code>sigma</code> <p>prior standard deviation of the baseline rates</p> required <code>sparsity_sigma</code> <code>float</code> <p>sparsity parameter, controls the prior on <code>tau</code>. Ignored if <code>tau</code> is provided.</p> <code>0.3</code> <code>tau</code> <code>Optional[float]</code> <p>if provided, will be used as the value of <code>tau</code> in the model</p> <code>None</code> <p>Returns:</p> Type Description <code>Model</code> <p>PyMC model. Use <code>model.theta</code> to access the (log-)mutual hazard network variable, which has shape (n_mutations, n_mutations)</p> Example <pre><code>model = prior_regularized_horseshoe(n_mutations=10)\nwith model:\n    theta = model.theta\n    pm.Potential(\"potential\", some_function_of(theta))\n</code></pre>"},{"location":"api/#pmhn.prior_normal","title":"<code>pmhn.prior_normal(n_mutations, mean=0.0, sigma=10.0, mean_offdiag=None, sigma_offdiag=None)</code>","text":"<p>Constructs PyMC model in which each entry is sampled from multivariate normal distribution.</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <code>float</code> <p>prior mean of the diagonal entries</p> <code>0.0</code> <code>sigma</code> <code>float</code> <p>prior standard deviation of the diagonal entries</p> <code>10.0</code> <code>mean_offdiag</code> <code>Optional[float]</code> <p>prior mean of the off-diagonal entries, defaults to <code>mean</code></p> <code>None</code> <code>sigma_offdiag</code> <code>Optional[float]</code> <p>prior standard deviation of the off-diagonal entries, defaults to <code>sigma</code></p> <code>None</code> Note <p>This model is unlikely to result in sparse solutions and for very weak priors (e.g., very large sigma) the solution may be very multimodal.</p>"},{"location":"api/#pmhn.prior_only_baseline_rates","title":"<code>pmhn.prior_only_baseline_rates(n_mutations, mean=0.0, sigma=10.0)</code>","text":"<p>Constructs a PyMC model in which the theta matrix contains only diagonal entries.</p>"},{"location":"api/#pmhn.prior_spike_and_slab_marginalized","title":"<code>pmhn.prior_spike_and_slab_marginalized(n_mutations, baselines_mean=0.0, baselines_sigma=10.0, sparsity_a=3.0, sparsity_b=1.0, spike_scale=0.1, slab_scale=10.0)</code>","text":"<p>Construct a spike-and-slab mixture prior for the off-diagonal entries.</p> <p>See the spike-and-slab mixture prior in this post.</p> <p>Parameters:</p> Name Type Description Default <code>n_mutations</code> <code>int</code> <p>number of mutations</p> required <code>baselines_mean</code> <code>float</code> <p>mean of the normal prior on the baseline rates</p> <code>0.0</code> <code>baselines_sigma</code> <code>float</code> <p>standard deviation of the normal prior on the baseline rates</p> <code>10.0</code> <code>sparsity_a</code> <code>float</code> <p>shape parameter of the Beta distribution controling sparsity</p> <code>3.0</code> <code>sparsity_b</code> <code>float</code> <p>shape parameter of the Beta distribution controling sparsity</p> <code>1.0</code> Note <p>By default we set <code>sparsity</code> prior Beta(3, 1) for $E[\\gamma] \\approx 0.75$, which should result in 75% of the off-diagonal entries being close to zero.</p>"},{"location":"api/#visualisations","title":"Visualisations","text":""},{"location":"api/#mutual-hazard-network-matrices","title":"Mutual Hazard Network matrices","text":""},{"location":"api/#pmhn.plot_theta","title":"<code>pmhn.plot_theta(theta, *, ax, gene_names=None, cmap=DEFAULT_COLORMAP, cbar=True, vmin=None, vmax=None, no_labels=False)</code>","text":""},{"location":"api/#pmhn.plot_offdiagonal_sparsity","title":"<code>pmhn.plot_offdiagonal_sparsity(thetas, *, ax, thresholds=(0.01, 0.1, 0.2), true_theta=None, true_theta_color='orangered', true_theta_label='Data', xlabel='Off-diagonal sparsity', ylabel='Count')</code>","text":"<p>Plots histogram representing the sparsity of the off-diagonal part of theta.</p> <p>Parameters:</p> Name Type Description Default <code>thetas</code> <code>ndarray</code> <p>Array of theta matrices, shape (n_samples, n_mutations, n_mutations)</p> required <code>ax</code> <code>Axes</code> <p>axis to plot on</p> required <code>thresholds</code> <code>Sequence[float]</code> <p>sparsity threshold (distinguishing between \"existing\" and \"non-existing\" interactions)</p> <code>(0.01, 0.1, 0.2)</code>"},{"location":"api/#pmhn.plot_offdiagonal_histograms","title":"<code>pmhn.plot_offdiagonal_histograms(thetas, *, ax, theta_true=None, alpha=0.1)</code>","text":""},{"location":"api/#pmhn.plot_theta_samples","title":"<code>pmhn.plot_theta_samples(theta_samples, *, width=4, height=3, theta_true=None)</code>","text":"<p>Plot samples from theta.</p>"},{"location":"api/#genotype-matrices","title":"Genotype matrices","text":""},{"location":"api/#pmhn.plot_genotypes","title":"<code>pmhn.plot_genotypes(genotypes, *, ax, patients_on_x_axis=True, patients_label='Patients', genes_label='Genes', sort=True)</code>","text":""},{"location":"api/#pmhn.plot_genotype_samples","title":"<code>pmhn.plot_genotype_samples(genotype_samples)</code>","text":""},{"location":"api/#misc","title":"Misc","text":""},{"location":"api/#pmhn.control_no_mutation_warning","title":"<code>pmhn.control_no_mutation_warning(silence=True)</code>","text":"<p>Silence the warning that is raised when a mutation matrix does not contain any mutation.</p>"},{"location":"api/#pmhn.construct_matrix","title":"<code>pmhn.construct_matrix(diag, offdiag)</code>","text":"<p>Constructs a square matrix from diagonal and offdiagonal terms.</p> <p>Parameters:</p> Name Type Description Default <code>diag</code> <code>ndarray</code> <p>array of shape (n,)</p> required <code>offdiag</code> <code>ndarray</code> <p>array of shape (n, n-1)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>array of shape (n, n) with the diagonal <code>diag</code> with the offdiagonal term at (k, i) given by offdiag[k, j(i)], where j(i) = i if i &lt; diagonal_index and then skips it for i &gt; diagonal_index</p> See Also <p>decompose_matrix, the inverse function.</p>"},{"location":"api/#pmhn.decompose_matrix","title":"<code>pmhn.decompose_matrix(matrix)</code>","text":"<p>Splits an (n, n) matrix into diagonal and offdiagonal terms.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>ndarray</code> <p>array of shape (n, n)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>diag, diagonal terms, shape (n,)</p> <code>ndarray</code> <p>offdiag, offdiagonal terms, shape (n, n-1)</p> See Also <p>construct_matrix, the inverse function.</p>"}]}